<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Golang源码之常见数据结构实现原理上 - NarcissusBlog</title><meta name="Description" content="Go语言专家编程书籍阅读笔记，常见数据结构的源码阅读，包括channel、slice、map。"><meta property="og:title" content="Golang源码之常见数据结构实现原理上" />
<meta property="og:description" content="Go语言专家编程书籍阅读笔记，常见数据结构的源码阅读，包括channel、slice、map。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://wen-nan.github.io/posts/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-30T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-11-30T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang源码之常见数据结构实现原理上"/>
<meta name="twitter:description" content="Go语言专家编程书籍阅读笔记，常见数据结构的源码阅读，包括channel、slice、map。"/>
<meta name="application-name" content="NarcissusBlog">
<meta name="apple-mobile-web-app-title" content="NarcissusBlog"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://wen-nan.github.io/posts/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861/" /><link rel="prev" href="http://wen-nan.github.io/posts/mysql45%E8%AE%B22/" /><link rel="next" href="http://wen-nan.github.io/posts/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%862/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Golang源码之常见数据结构实现原理上",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/wen-nan.github.io\/posts\/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861\/"
        },"genre": "posts","keywords": "Golang","wordcount":  5813 ,
        "url": "http:\/\/wen-nan.github.io\/posts\/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861\/","datePublished": "2021-11-30T00:00:00+00:00","dateModified": "2021-11-30T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": "Narcissus"},"author": {
                "@type": "Person",
                "name": "Narcissus"
            },"description": "Go语言专家编程书籍阅读笔记，常见数据结构的源码阅读，包括channel、slice、map。"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="NarcissusBlog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/mechanic.png"
        data-srcset="/mechanic.png, /mechanic.png 1.5x, /mechanic.png 2x"
        data-sizes="auto"
        alt="/mechanic.png"
        title="/mechanic.png" />NarcissusBlog</a>
        </div>
        <div class="menu">
            <div class="menu-inner">
                <a class="menu-item" href="/posts/" title="全部文章"><i class="fa fa-fw fa-bars"></i> 全部文章 
                        </a><a class="menu-item" href="/categories/" title="分类"><i class="fas fa-fw fa-th"></i> 分类 
                        </a><a class="menu-item" href="/tags/" title="标签"><i class="fas fa-fw fa-tag"></i> 标签 
                        </a>
                        <div class="dropdown">
                            <a href="javascript:void(0);" class="menu-item menu-more dropbtn" title="文档" ><i class='fas fa-fw fa-fan fa-spin'></i> 文档 
                            </a>
                            <div class="menu-more-content dropdown-content"><a href="https://gohugo.io/documentation/" title="" target="_blank" rel="noopener"><i class='fa fa-thumbs-up'></i> Hugo文档 </a></div>
                        </div>
                    <a class="menu-item" href="/about/" title="关于"><i class="fas fa-fw fa-at"></i> 关于 
                        </a><a class="menu-item" href="https://github.com/wen-nan" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  
                        </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="NarcissusBlog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/mechanic.png"
        data-srcset="/mechanic.png, /mechanic.png 1.5x, /mechanic.png 2x"
        data-sizes="auto"
        alt="/mechanic.png"
        title="/mechanic.png" />NarcissusBlog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="全部文章"><i class="fa fa-fw fa-bars"></i> 全部文章 
                    </a><a class="menu-item" href="/categories/" title="分类"><i class="fas fa-fw fa-th"></i> 分类 
                    </a><a class="menu-item" href="/tags/" title="标签"><i class="fas fa-fw fa-tag"></i> 标签 
                    </a>
                    <div class="dropdown">
                        <a href="javascript:void(0);" class="menu-item menu-more dropbtn" title="文档" ><i class='fas fa-fw fa-fan fa-spin'></i> 文档 
                        </a>
                        <div class="menu-more-content dropdown-content"><a href="https://gohugo.io/documentation/" title="" target="_blank" rel="noopener"><i class='fa fa-thumbs-up'></i> Hugo文档 </a></div>
                    </div>
                <a class="menu-item" href="/about/" title="关于"><i class="fas fa-fw fa-at"></i> 关于 
                    </a><a class="menu-item" href="https://github.com/wen-nan" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  
                    </a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Golang源码之常见数据结构实现原理上</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Narcissus</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/golang/"><i class="far fa-folder fa-fw"></i>Golang</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-11-30">2021-11-30</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5813 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 12 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#channel">Channel</a>
      <ul>
        <li><a href="#1-前言">1. 前言</a></li>
        <li><a href="#2-chan数据结构">2. chan数据结构</a>
          <ul>
            <li><a href="#21-环形队列">2.1 环形队列</a></li>
            <li><a href="#22-等待队列">2.2 等待队列</a></li>
            <li><a href="#23-锁">2.3 锁</a></li>
          </ul>
        </li>
        <li><a href="#3-channel读写">3. channel读写</a>
          <ul>
            <li><a href="#31-创建channel">3.1 创建channel</a></li>
            <li><a href="#32-向channel写数据">3.2 向channel写数据</a></li>
            <li><a href="#33-从channel读数据">3.3 从channel读数据</a></li>
            <li><a href="#34-关闭channel">3.4 关闭channel</a></li>
          </ul>
        </li>
        <li><a href="#常见用法">常见用法</a>
          <ul>
            <li><a href="#41-单向channel">4.1 单向channel</a></li>
            <li><a href="#42-select">4.2 select</a></li>
            <li><a href="#43-range">4.3 range</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#slice">Slice</a>
      <ul>
        <li><a href="#1-前言-1">1. 前言</a></li>
        <li><a href="#2-实现原理">2. 实现原理</a>
          <ul>
            <li><a href="#21-slice数据结构">2.1 Slice数据结构</a></li>
            <li><a href="#22-使用make创建slice">2.2 使用make创建Slice</a></li>
            <li><a href="#23-使用数组创建slice">2.3 使用数组创建Slice</a></li>
            <li><a href="#24-slice扩容">2.4 Slice扩容</a></li>
            <li><a href="#25-slice-copy">2.5 Slice copy</a></li>
            <li><a href="#26-特殊切片">2.6 特殊切片</a></li>
          </ul>
        </li>
        <li><a href="#3-编程tips">3. 编程Tips</a>
          <ul>
            <li><a href="#题目">题目</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#map">Map</a>
      <ul>
        <li><a href="#1-map数据结构">1. map数据结构</a></li>
        <li><a href="#2-哈希冲突">2. 哈希冲突</a></li>
        <li><a href="#3-key定位过程">3. key定位过程</a></li>
        <li><a href="#4-渐进式扩容">4. 渐进式扩容</a>
          <ul>
            <li><a href="#41-扩容的前提条件">4.1 扩容的前提条件</a></li>
            <li><a href="#42-增量式扩容">4.2 增量式扩容</a></li>
            <li><a href="#43-等量扩容">4.3 等量扩容</a></li>
          </ul>
        </li>
        <li><a href="#5-map进阶">5. map进阶</a>
          <ul>
            <li><a href="#可以边遍历边删除吗">可以边遍历边删除吗？</a></li>
            <li><a href="#key可以是float型吗">key可以是float型吗？</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="channel">Channel</h2>
<h3 id="1-前言">1. 前言</h3>
<p>channel是Golang提供的goroutine间通信方式，主要用于进程内各goroutine间通信。源代码位于<code>runtime/chan.go</code>中。</p>
<h3 id="2-chan数据结构">2. chan数据结构</h3>
<p><code>src/runtime/chan.go:hchan</code>中定义了channel的数据结构：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.47.26.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.47.26.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.47.26.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.47.26.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.47.26.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.47.26.png" /></p>
<h4 id="21-环形队列">2.1 环形队列</h4>
<p>chan内部实现了一个环形队列作为其缓冲区，队列长度是创建chan时指定。如下图：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.50.40.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.50.40.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.50.40.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.50.40.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.50.40.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2014.50.40.png" /></p>
<ul>
<li>dataqsiz指示了队列长度为6，即可缓存6个元素</li>
<li>qcount表示队列中还有2个元素</li>
<li>sendx表示后续写入的数据存储的位置，取值[0, 6)</li>
<li>recvx表示从该位置读取数据，取值[0, 6)</li>
</ul>
<h4 id="22-等待队列">2.2 等待队列</h4>
<p>从channel读数据，如果channel缓冲区为空或者没有缓存区；向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine均会被阻塞，被挂在channel的等待队列中。</p>
<ul>
<li>因读阻塞的goroutine会被向channel写入数据的gorooutine唤醒；</li>
<li>因写阻塞的goroutine会被从channel读出数据的gorooutine唤醒；</li>
</ul>
<p>下图展示了一个没有缓冲区的channel，有几个因读阻塞的goroutine：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.01.56.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.01.56.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.01.56.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.01.56.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.01.56.png"
        title="ScreenShot2021-11-30 15.01.56" /></p>
<blockquote>
<p>注意：一般情况下，recvq和sendq至少有一个为空。但有一个例外就是同一个goroutine使用select语句向channel一边写一边读。</p>
</blockquote>
<h4 id="23-锁">2.3 锁</h4>
<p>一个channel同时仅允许被一个goroutine读写，因此有锁。</p>
<h3 id="3-channel读写">3. channel读写</h3>
<h4 id="31-创建channel">3.1 创建channel</h4>
<p>创建channel的过程实际上就是初始化<code>hchan</code>结构，由<code>runtime/chan.go:makechan()</code>函数实现，类型信息和缓冲区长度由make语句传入，<code>buf</code>的大小由元素类型和缓冲区长度共同决定。伪代码如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.09.01.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.09.01.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.09.01.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.09.01.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.09.01.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.09.01.png" /></p>
<h4 id="32-向channel写数据">3.2 向channel写数据</h4>
<p>向一个channel中写数据过程如下：</p>
<ol>
<li>如果等待接收队列<code>recvq</code>不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从<code>recvq</code>中取出G，并把数据写入唤醒的G，结束写过程；</li>
<li>如果缓冲区有空余位置，将数据写入缓冲区，结束写过程；</li>
<li>如果缓冲区没有空余位置，将待写数据写入G，并将当前G加入<code>sendq</code>，进入睡眠；等待读goroutine唤醒；</li>
</ol>
<p>流程图如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.22.25.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.22.25.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.22.25.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.22.25.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.22.25.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.22.25.png" /></p>
<h4 id="33-从channel读数据">3.3 从channel读数据</h4>
<p>从一个channel读数据过程如下：</p>
<ol>
<li>如果等待发送队列<code>sendq</code>不为空并且没有缓冲区，直接取出G，把数据读出并唤醒G，结束读过程；</li>
<li>如果等待发送队列<code>sendq</code>不为空，说明缓冲区已满，先从缓冲区首部读出数据，然后把G中数据写入缓冲区尾部并唤醒G,结束读过程；</li>
<li>如果缓冲区有数据，从缓冲区读取数据，解说读过程；</li>
<li>将当前读的goroutine加入<code>recvq</code>，进入睡眠，等待被写goroutine唤醒。</li>
</ol>
<p>流程图如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.29.03.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.29.03.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.29.03.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.29.03.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.29.03.png"
        title="ScreenShot2021-11-30 15.29.03" /></p>
<h4 id="34-关闭channel">3.4 关闭channel</h4>
<p>关闭channel时会把<code>recvq</code>中的G全部唤醒，本该写入G的数据位置为nil；把<code>sendq</code>中的G全部唤醒，但这些G会panic。</p>
<p>除此之外，还会panic的场景有：</p>
<ul>
<li>关闭值为nil的channel</li>
<li>关闭已经关闭的channel</li>
<li>向已经关闭的channel写数据</li>
</ul>
<h3 id="常见用法">常见用法</h3>
<h4 id="41-单向channel">4.1 单向channel</h4>
<p>单向channel指只能用于发送或接收数据，实际上没有单向channel，只是对channel的一种使用限制。</p>
<p>简单例子：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.54.00.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.54.00.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.54.00.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.54.00.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2015.54.00.png"
        title="ScreenShot2021-11-30 15.54.00" /></p>
<p>mychan是一个正常的channel，<code>func readChan(chanName &lt;-chan int)</code>通过形参限定函数内部只能从channel中读取数据；<code>func writeChan(chanName chan&lt;- int)</code>通过形参限定函数内部只能向channel中写入数据。</p>
<h4 id="42-select">4.2 select</h4>
<p>使用select可以监控多个channel，例如监控多个channel，当某一个channel有数据时，就从其读出数据，代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">addNumberToChan</span><span class="p">(</span><span class="nx">chanName</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">chanName</span> <span class="o">&lt;-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">chan1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">chan2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">addNumberToChan</span><span class="p">(</span><span class="nx">chan1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nf">addNumberToChan</span><span class="p">(</span><span class="nx">chan2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">e</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">chan1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Get element from chan1:%d\n&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">e</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">chan2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Get element from chan2:%d\n&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;No element from chan1 and chan2\n&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>代码结果如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.06.30.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.06.30.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.06.30.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.06.30.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.06.30.png"
        title="ScreenShot2021-11-30 16.06.30" /></p>
<p>可以看出，select语句的多个case执行顺序是随机的。</p>
<blockquote>
<p>通过示例可知:<strong>select的case语句读channel不会阻塞，尽管channel中没有数据。这时由于case语句编译后调用读channel时会明确传入不阻塞的参数，此时读不到数据不会将当前goroutine加入等待队列，而是直接返回</strong>。</p>
</blockquote>
<h4 id="43-range">4.3 range</h4>
<p>通过range可以持续从channel中读取数据，好像在遍历一个数组一样，<strong>当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样</strong>。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.14.49.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.14.49.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.14.49.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.14.49.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.14.49.png"
        title="ScreenShot2021-11-30 16.14.49" /></p>
<blockquote>
<p>注意：如果此时channel写数据的goroutine退出时，系统检测到这种情况会panic，否则range将会永久阻塞。</p>
</blockquote>
<h2 id="slice">Slice</h2>
<h3 id="1-前言-1">1. 前言</h3>
<p>Slice又称动态数组，依托数组实现，可以方便进行扩容、传递等，实际使用中比数组更灵活。</p>
<h3 id="2-实现原理">2. 实现原理</h3>
<p>Slice依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以自动重分配并生成新的Slice。源代码在<code>src/runtime/slice.go</code>中。</p>
<h4 id="21-slice数据结构">2.1 Slice数据结构</h4>
<p>源码包中<code>src/runtime/slice.go:slice</code>定义了Slice的数据结构：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.34.23.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.34.23.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.34.23.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.34.23.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.34.23.png"
        title="ScreenShot2021-11-30 16.34.23" /></p>
<p>array指针指向底层数组，len表示切片长度，cap表示<strong>底层数组容量</strong>。</p>
<h4 id="22-使用make创建slice">2.2 使用make创建Slice</h4>
<p>使用make创建Slice时，可以同时指定长度和容量，创建时底层会分配一个数组，<strong>数组的长度即容量</strong>。例如，<code>slice := make([]int, 5, 10)</code>结构如下图：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.37.37.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.37.37.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.37.37.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.37.37.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.37.37.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.37.37.png" /></p>
<p>该Slice长度为5，即可以使用下标slice[0]~slice[4]来操作里面的元素。容量为10，表示后续向Slice添加新元素时可以不必重新分配内存，直接使用 预留内存即可。</p>
<blockquote>
<p>注意：若不指定容量，则表示容量等于长度。</p>
</blockquote>
<h4 id="23-使用数组创建slice">2.3 使用数组创建Slice</h4>
<p>使用数组来创建Slice时，Slice将与原数组共用一部分内存。例如，<code>slice := array[5:7]</code>如下图所示：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.44.21.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.44.21.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.44.21.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.44.21.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.44.21.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.44.21.png" /></p>
<blockquote>
<p>注意：原数组后面的内容都作为切片的预留内存，数组和切片操作都可能作用于同一块内存。</p>
</blockquote>
<h4 id="24-slice扩容">2.4 Slice扩容</h4>
<p>使用append向Slice追加元素时，如果Slice空间不足，将会触发扩容。实质是重新分配一块更大的内存，将原Slice中元素拷贝进新Slice中，然后再追加新元素。如下图：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.49.11.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.49.11.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.49.11.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.49.11.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.49.11.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2016.49.11.png" /></p>
<p>扩容操作只关心容量，会把原Slice数据拷贝到新Slice中，追加数据由append在扩容结束后完成。上图可以看到，扩容后长度仍然是5。</p>
<blockquote>
<p>扩容容量选择规则如下：</p>
<ul>
<li>如果原Slice容量小于1024，则新Slice容量扩大为原来的2倍。</li>
<li>如果原Slice容量大于或等于1024，则新Slice容量扩大为原来的1.25倍。</li>
</ul>
<p><strong>但最新有小小修改</strong>:</p>
<ol>
<li><code>threshold = 256</code>,门槛由1024变成了256；</li>
<li><code>newcap += (newcap + 3*threshold) / 4</code>,而不是之前的<code>newcap += newcap / 4</code></li>
</ol>
</blockquote>
<p>程序代码片段如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.16.47.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.16.47.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.16.47.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.16.47.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.16.47.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.16.47.png" /></p>
<h4 id="25-slice-copy">2.5 Slice copy</h4>
<p>使用内置函数copy()拷贝两个切片时，会将源切片数据逐个拷贝到目标切片的数组中，<strong>拷贝数量取两个切片长度的最小值</strong>。即长度为10的切片拷贝到长度为5的切片，将会拷贝5个元素。</p>
<blockquote>
<p>copy过程中不会发生扩容</p>
</blockquote>
<h4 id="26-特殊切片">2.6 特殊切片</h4>
<p>根据数组或切片生成新切片一般使用<code>slice := array[start:end]</code>方式，这种方式没有指定切片容量，<strong>实际上新切片容量就是从start开始直至array的结束</strong>。</p>
<p>例如下面的例子，长度和容量都是一致，共用内存：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.31.00.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.31.00.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.31.00.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.31.00.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.31.00.png"
        title="ScreenShot2021-11-30 17.31.00" /></p>
<p>但还有另一种写法，即切片同时也指定容量，<code>slice[start:end:cap]</code>，其中<code>cap</code>即为新切片的容量，<strong>当然容量不能超过原切片实际值(会做语法检测，编译不通过)</strong>，如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.33.03.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.33.03.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.33.03.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.33.03.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.33.03.png"
        title="ScreenShot2021-11-30 17.33.03" /></p>
<h3 id="3-编程tips">3. 编程Tips</h3>
<ul>
<li>创建切片时可根据实际需求预分配容量，尽量避免追加过程中扩容操作，利于提升性能；</li>
<li>切片拷贝时需要判断实际拷贝的元素个数；</li>
<li>谨慎使用多个切片操作同一数组，以防读写冲突。</li>
</ul>
<h4 id="题目">题目</h4>
<p>下列程序输出什么？</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.41.44.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.41.44.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.41.44.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.41.44.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-11/ScreenShot2021-11-30%2017.41.44.png"
        title="ScreenShot2021-11-30 17.41.44" /></p>
<p>参考答案：append函数执行时会判断切片容量是否能够存放新增元素，如果不能，则会重新申请存储空间，新存储空间将是原来的2倍或1.25倍（取决于扩展原空间大小），本例中实际执行了两次append操作，第一次空间增长到4， 所以第二次append不会再扩容，所以新旧两个切片将共用一块存储空间。程序会输出true。</p>
<h2 id="map">Map</h2>
<p>map的设计被称作”The dictionary problem“, 它的任务是设计一种数据结构用来维护一个集合的数据，并且可以对集合进行增删查改操作。最主要的数据结构有两种：<strong>哈希查找表、搜索树</strong>。</p>
<ul>
<li>哈希查找表</li>
</ul>
<p>用一个哈希函数将key分配到不同的桶（bucket,也就是数组不同的index）。一般会存在”碰撞“问题（即不同的key被哈希到同一个bucket）。一般有两种应对方法：<strong>链表法和开放地址法</strong>。</p>
<blockquote>
<p>链表法将一个bucket实现成一个链表，落在同一个bucket中的key都会插入这个链表。</p>
<p>开放地址法则是发生碰撞后，通过一定的规律，在数组后面挑选空位，用来存放新的key。</p>
</blockquote>
<ul>
<li>搜索树</li>
</ul>
<p>搜索树一般采用自平衡搜索树，包括：AVL树，红黑树。</p>
<p><strong>Go语言采用的是哈希查找表，并且使用链表解决哈希冲突</strong>。</p>
<h3 id="1-map数据结构">1. map数据结构</h3>
<p>源码位于<code>src/runtime/map.go</code>中，表示map的结构体是<code>hmap</code>：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.02.23.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.02.23.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.02.23.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.02.23.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.02.23.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.02.23.png" /></p>
<p>buckets是一个指针，指向bucket结构体的数组，bucket结构体<code>bmap</code>如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.07.08.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.07.08.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.07.08.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.07.08.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.07.08.png"
        title="ScreenShot2021-12-01 15.07.08" /></p>
<blockquote>
<p>注意：</p>
<ol>
<li>结构体中只显示定义了tophash,data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</li>
<li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配</li>
<li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放<strong>是为了节省字节对齐带来的空间浪费</strong>。</li>
<li>每个bucket最多只能存放8个key-value对，overflow指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li>
</ol>
</blockquote>
<p>如下图展示了存放8个键值对的示意图：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.15.02.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.15.02.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.15.02.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.15.02.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.15.02.png"
        title="ScreenShot2021-12-01 15.15.02" /></p>
<h3 id="2-哈希冲突">2. 哈希冲突</h3>
<p>当有两个或以上数量的键被哈希到同一个bucket时，就称发生了冲突。由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个bucket，通过overflow指针连接起来。</p>
<p><strong>因为Go的bucket可能存放8个键值对，所以能容忍更高的负载因子(<code>负载因子=键数量/bucket数量</code>)，在负载因子达到6.5时才会触发rehash</strong>。</p>
<h3 id="3-key定位过程">3. key定位过程</h3>
<p>key经过哈希计算后得到哈希值，共64个bit位（对于64位机），计算它到底落在哪个桶，只会用到最后B个bit位。如果B=5，那么桶数量，也就是buckets数组长度就是2^5=32。</p>
<p>例如，有一个key经过哈希后得到如下结果：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.37.12.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.37.12.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.37.12.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.37.12.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.37.12.png"
        title="ScreenShot2021-12-01 15.37.12" /></p>
<p>用最后5个bit位，也就是<code>01010</code>，值为10，就是10号桶。再用哈希值高8位，找到此key在bucket中的位置。</p>
<p>下面具体说明定位过程，如图：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.39.27.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.39.27.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.39.27.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.39.27.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.39.27.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2015.39.27.png" /></p>
<blockquote>
<p>上图中，B=5,所以buckets总数是32.首先计算出key的哈希值，用最低5位<code>00110</code>，确定6号桶。使用高8位<code>10010111</code>，对应十进制151，在6号bucket中寻找<code>tophash</code>值（HOB hash）为151的key,找到了2号槽位，然后去keys数组的对应位置查找到key2，如果该key2与key相同，则返回value2，结束。</p>
<p>如果在bucket中没有找到，并且overflow不为空，则还要继续去overflow bucket中寻找，最后没找到<strong>则返回对应值类型的0值</strong>。</p>
</blockquote>
<h3 id="4-渐进式扩容">4. 渐进式扩容</h3>
<h4 id="41-扩容的前提条件">4.1 扩容的前提条件</h4>
<p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。扩容的条件有如下两个：</p>
<ul>
<li>装载因子超过阈值，阈值定义为6.5。</li>
<li>overflow的bucket数量过多，当B 小于15（也就是bucket总数小于2^15时），如果overflow的bucket数量超过2^B;当B 大于等于15（也就是bucket总数大于等于2^15时），如果overflow的bucket数量超过2^15。</li>
</ul>
<h4 id="42-增量式扩容">4.2 增量式扩容</h4>
<p>增量式扩容主要用于元素太多而bucket太少的情况。一次性搬迁非常影响性能，<strong>Go每次最多搬迁2个bucket，搬迁前会分配新的buckets(长度是原来的2倍),并将老的buckets挂到oldbuckets字段上，后续插入、删除、修改key的时候，都会尝试搬迁工作，直到搬迁完成（即oldbuckets为nil）</strong>。</p>
<p>由于新的buckets是老的buckets的2倍，所以可以按序号来搬，比如原来在0号buckets，到新的地方后，仍然放到0号buckets。</p>
<h4 id="43-等量扩容">4.3 等量扩容</h4>
<p>在overflow的bucket数量增多，但负载因子又不高的情况下，但大多数overflow的buckets是空的，则需要进行等量扩容。<strong>即buckets数量不变， 经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率</strong>。</p>
<p>对于这种情况，就需要重新计算key的哈希值，称为<code>rehash</code>。比如B原来为5，扩容后B变成了6,就需要多看一位。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2016.18.11.png"
        data-srcset="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2016.18.11.png, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2016.18.11.png 1.5x, https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2016.18.11.png 2x"
        data-sizes="auto"
        alt="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2016.18.11.png"
        title="https://narcissusblog-img.oss-cn-beijing.aliyuncs.com/uPic/file-12/ScreenShot2021-12-01%2016.18.11.png" /></p>
<blockquote>
<p><strong>为什么遍历map是无序的？</strong></p>
<p>map在扩容后，会发生key的搬迁，原来落在同一个bucket中的key，搬迁后，某些key就会远走高飞了。而遍历过程是按顺序遍历bucket，再按顺序遍历bucket中的key。搬迁后key位置发生了重大变化，遍历结果就不可能有序了。</p>
<p><strong>但有一个hard code的map，并且不会有插入删除操作，按道理每次遍历结果应该有序呢？</strong></p>
<p>的确是这样，但Go杜绝了这种情况，go1.0加入了”迭代map的结果是无须的“这个特性。遍历map时，并不是从固定的0号bucket开始遍历，每次都从一个随机值序号开始遍历。</p>
</blockquote>
<h3 id="5-map进阶">5. map进阶</h3>
<h4 id="可以边遍历边删除吗">可以边遍历边删除吗？</h4>
<p><strong>map并不是一个线程安全的数据结构</strong>。同时读写一个map是未定义的行为，被检测到会直接panic。可以通过读写锁<code>sync.RWMutex</code>来解决。另外，<code>sync.Map</code>是线程安全的map,可以使用。</p>
<h4 id="key可以是float型吗">key可以是float型吗？</h4>
<p>语法上是可以的。Go语言中只要是可比较的类型都可以作为key。</p>
<blockquote>
<p><strong>除开slice、map、function，其他类型都可以</strong>。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。结构体需要它们的字段值都相等才会被认为是相同的key。</p>
<p><strong>任何类型都可以作为value,包括map类型</strong>。</p>
</blockquote>
<p>float型可以作为key，但由于精度的问题，会导致一些诡异的问题。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-11-30</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="http://wen-nan.github.io/posts/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861/" data-title="Golang源码之常见数据结构实现原理上" data-hashtags="Golang"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://wen-nan.github.io/posts/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861/" data-hashtag="Golang"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://wen-nan.github.io/posts/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861/" data-title="Golang源码之常见数据结构实现原理上" data-ralateuid="dengzhicheng123"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="http://wen-nan.github.io/posts/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%861/" data-title="Golang源码之常见数据结构实现原理上"><i data-svg-src="/lib/simple-icons/icons/baidu.min.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/golang/">Golang</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/mysql45%E8%AE%B22/" class="prev" rel="prev" title="MySQL:事务"><i class="fas fa-angle-left fa-fw"></i>MySQL:事务</a>
            <a href="/posts/golang%E6%BA%90%E7%A0%81_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%862/" class="next" rel="next" title="Golang源码之常见数据结构实现原理下">Golang源码之常见数据结构实现原理下<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments">
        <div id="gitalk" class="comment"></div>
        <link rel="stylesheet" href="/js/gitalk.css">
        <script src="/js/gitalk.min.js"></script>
        <script src="/js/md5.js"></script>
        <script>
        const gitalk = new Gitalk({
            clientID: '60afa8aa721493fdc40a',
            clientSecret: '0d83669766bc4d55f49702f8d22e76215dfb373a',
            repo: 'wen-nan.github.io',
            owner: 'wen-nan',
            admin: ['wen-nan'],
            
            
            id: md5(location.pathname), 
            distractionFreeMode: false 
        });
        (function() {
            if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
                document.getElementById('gitalk').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
                return;
            }
            gitalk.render('gitalk');
        })();
        </script>
        </div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                <span id="run-time"></span>
            </div><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.109.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Narcissus</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript" src="/js/custom.js"></script></body>
</html>
